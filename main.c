/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"



int main(void)
{
	//Настраиваем систему тактирования на внешний кварцевый резонатор(HSE)
	SystemClockInit();

	//Тактируем порт кнопки - GPIOC
	*(volatile uint32_t*)(RCC_REG + RCC_AHB1ENR_OFFSET) |= (1 << 2);
	//По умолчанию уже настроен на вход, ничего большен не нужно

	//Тактируем порт светодиодов - GPIOD
	*(volatile uint32_t*)(RCC_REG + RCC_AHB1ENR_OFFSET) |= (1 << 3);

	//Настраиваем диоды на выход

	*(volatile uint32_t*)(GPIOD_REG + GPIO_MODER_OFFSET) |= (1 << 26); // set GPIO type 13 led out

	*(volatile uint32_t*)(GPIOD_REG + GPIO_MODER_OFFSET) |= (1 << 28); // set GPIO type 14 led out

	*(volatile uint32_t*)(GPIOD_REG + GPIO_MODER_OFFSET) |= (1 << 30); // set GPIO type 15 led out

	//Инициаилизиуем таймер 2 - для моргания

	//Тактируем таймер
	*(volatile uint32_t*)(RCC_REG + RCC_APB1ENR_OFFSET) |= (1 << 0);
	//Разрешаем прерывание от таймера в NVIC
	*(volatile uint32_t*)(NVIC_ISER0_REG) |= (1 << 28);
	//Ставим делитель частоты(1 миллисекунда при тактовой частоте 25 МГц)
	*(volatile uint32_t*)(TIMER2_REG + TIMER_PSC_OFFSET) = 24999;
	//Ставим по умолчанию ARR как для 1го режима (100 миллисекунд)
	*(volatile uint32_t*)(TIMER2_REG + TIMER_ARR_OFFSET) = MODE_1_BLINK_PERIOD;
	//Разрешаем прерывание в периферии
	*(volatile uint32_t*)(TIMER2_REG + TIMER_DIER_OFFSET) |= (1 << 0); // разрешение прерывания
	//Включаем таймер!
	*(volatile uint32_t*)(TIMER2_REG + TIMER_CR1_OFFSET) |= (1 << 0);

	//Timer 3
	*(volatile uint32_t*)(RCC_REG + RCC_APB1ENR_OFFSET) |= (1 << 1);
	*(volatile uint32_t*)(NVIC_ISER0_REG) |= (1 << 29);
	*(volatile uint32_t*)(TIMER3_REG + TIMER_PSC_OFFSET) = 24999;
	*(volatile uint32_t*)(TIMER3_REG + TIMER_ARR_OFFSET) = BUTTON_NOISE_WAIT_TIME;	//Время для антидребезга (150 миллисекунд)
	*(volatile uint32_t*)(TIMER3_REG + TIMER_DIER_OFFSET) |= (1 << 0);




    while(1){
    	// РАБОТА С КНОПКОЙ
    	//Ждем отжатия
		if(!isBtn_waitForClick){
			if(!(*(volatile uint32_t*)(GPIOC_REG + GPIO_IDR_OFFSET) & (1 << 15))){
				isBtn_waitForClick = 1;
				isBtn_clicked = 1;
				//Включаем таймер
				*(volatile uint32_t*)(TIMER3_REG + TIMER_CR1_OFFSET) |= (1 << 0);
			}
		}
		//Ждем нажатия кнопки
		if(isBtn_clicked){
			if(*(volatile uint32_t*)(GPIOC_REG + GPIO_IDR_OFFSET) & (1 << 15)){
				if(isBtn_waitForRelease){
					isBtn_clicked = 0;
					isBtn_waitForClick = 0;
					isBtn_waitForRelease = 0;

					//Следующий режим
					ledMode++;
					if(ledMode > 3){
						ledMode = 0;
					}

					setLedMode(ledMode);
				} else{
					//Запускаем таймер 3
					*(volatile uint32_t*)(TIMER3_REG + TIMER_CR1_OFFSET) |= (1 << 0);
					isBtn_clicked = 0;
					isBtn_waitForRelease = 1;
				}
			}
		}
    }

}

//Обработчик прерывания по таймеру 2
void TIM2_IRQHandler(){
	*(volatile uint32_t*)(TIMER2_REG + TIMER_SR_OFFSET) &= ~(1 << 0);
	processLedMode();
}

//Функция вкл/выкл диодов
void processLedMode(){

	switch(ledMode){
	case 0:
		if(blink_mode1_ActiveLeds[blink_mode1_current_stage] == 'n'){
			blink_mode1_current_stage = 0;
		}
		switch_Led(blink_mode1_ActiveLeds[blink_mode1_current_stage]);
		blink_mode1_current_stage++;
		break;
	case 1:
		if(blink_mode2_ActiveLeds[blink_mode2_current_stage] == 'n'){
			blink_mode2_current_stage = 0;
		}
		switch_Led(blink_mode2_ActiveLeds[blink_mode2_current_stage]);
		blink_mode2_current_stage++;
		break;
	case 2:
		if(blink_mode3_ActiveLeds[blink_mode3_current_stage] == 'n'){
			blink_mode3_current_stage = 0;
		}
		switch_Led(blink_mode3_ActiveLeds[blink_mode3_current_stage]);
		blink_mode3_current_stage++;
		break;
	case 3:
		if(blink_mode4_ActiveLeds[blink_mode4_current_stage] == 'n'){
			blink_mode4_current_stage = 0;
		}
		switch_Led(blink_mode4_ActiveLeds[blink_mode4_current_stage]);
		blink_mode4_current_stage++;
		break;
	}
}


void switch_Led(char ledColour){
	switch(ledColour){
	case 'r':
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) |= (1 << 13);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 14);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 15);
		break;
	case 'g':
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 13);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) |= (1 << 14);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 15);
		break;
	case 'b':
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 13);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 14);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) |= (1 << 15);
		break;
	case 'n':
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 13);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 14);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 15);
		break;
	}
}

//Функция установки режима моргания для изменения частоты
void setLedMode(uint8_t mode){

	//Останавливаем таймер 2
	*(volatile uint32_t*)(TIMER2_REG + TIMER_CR1_OFFSET) &= ~(1 << 0);
	//Чистим каунтер
	*(volatile uint32_t*)(TIMER2_REG + TIMER_CNT_OFFSET) = 0;

	switch(mode){
	case 0:
		ledMode = 0;
		setLedFrequencyMode(blink_mode1_frequency);
		break;
	case 1:
		ledMode = 1;
		setLedFrequencyMode(blink_mode2_frequency);
		break;
	case 2:
		ledMode = 2;
		setLedFrequencyMode(blink_mode3_frequency);
		break;
	case 3:
		ledMode = 3;
		setLedFrequencyMode(blink_mode4_frequency);
		break;
	}

	//вызываем нашу функцию работы с диодами
	processLedMode();

	//Запускаем таймер
	*(volatile uint32_t*)(TIMER2_REG + TIMER_CR1_OFFSET) |= (1 << 0);
}

//Функция для установки режима моргания(период срабатывания таймера 2)
void setLedFrequencyMode(uint8_t mode){
	switch(mode){
	case 1:
		*(volatile uint32_t*)(TIMER2_REG + TIMER_ARR_OFFSET) = MODE_1_BLINK_PERIOD;
		break;
	case 2:
		*(volatile uint32_t*)(TIMER2_REG + TIMER_ARR_OFFSET) = MODE_2_BLINK_PERIOD;
		break;
	case 3:
		*(volatile uint32_t*)(TIMER2_REG + TIMER_ARR_OFFSET) = MODE_3_BLINK_PERIOD;
		break;
	case 4:
		*(volatile uint32_t*)(TIMER2_REG + TIMER_ARR_OFFSET) = MODE_4_BLINK_PERIOD;
		break;
	}
}

//Обработчик прерывания по таймеру 3

void TIM3_IRQHandler(){

	*(volatile uint32_t*)(TIMER3_REG + TIMER_SR_OFFSET) &= ~(1 << 0);

	if(isBtn_waitForRelease){
		//Если после прихода таймера до сих пор активный уровень - значит, кнопка нажата
		if(*(volatile uint32_t*)(GPIOC_REG + GPIO_IDR_OFFSET) & (1 << 15)){
			isBtn_clicked = 1;
		}
	} else{
		//Если после прихода таймера до сих пор НЕактивный уровень - значит, кнопка отжата
		if(!(*(volatile uint32_t*)(GPIOC_REG + GPIO_IDR_OFFSET) & (1 << 15))){
			isBtn_clicked = 1;
		}
	}
	//Выключаем таймер
	*(volatile uint32_t*)(TIMER3_REG + TIMER_CR1_OFFSET) &= ~(1 << 0);


}

//Функция настроки системы тактирования
void SystemClockInit(){
	//Сперва используем внутренний тактовый генератор - HSI
	//Устанавливаем 0 бит в RCC_CR_OFFSET в 1 - HSION, включаем внутренний тактовый генератор на время настройки
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) |= (1 << 0); //HSION


  //Устанавливаем биты SW1 и SW2 в ноль - выбираем HSI как системный тактовый генератор(т.е. основной)
  *(volatile uint32_t*)(RCC_REG + RCC_CFGR_OFFSET) &= ~(1 << 0); //SW1
  *(volatile uint32_t*)(RCC_REG + RCC_CFGR_OFFSET) &= ~(1 << 1); //SW2

  //В регистре CR ставим в ноль биты HSE, CSS, PLL
  //CSS - система защиты частоты, она нам не нужна
  //PLL - умножитель частоты, он нам тут тоже не нужен
  //HSE пока выключаем
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) &= ~(1 << 16); //HSE OFF
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) &= ~(1 << 19); //CSS OFF
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) &= ~(1 << 24); //PLL OFF

  //Теперь начнем влючать внешний тактовый генератор - HSE
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) |= (1 << 16); //HSEON
  //Пока частота HSE не стабилизируется - виснем
  while( (*(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) & (1 << 17)) == 0 ); // ждем стабилизации частоты HSE

  //В регистре CFGR выбираем HSE как системный тактовый генератор
  *(volatile uint32_t*)(RCC_REG + RCC_CFGR_OFFSET) |= (1 << 0); //SW1

  //Выключаем HSI
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) &= ~(1 << 0); //HSION

  //Если ВДРУГ у нас системный тактовый генератор не HSE - виснем, что-то пошло не так
  while( ( *(volatile uint32_t*)(RCC_REG + RCC_CFGR_OFFSET) & (1 << 2)) == 0 );
}
